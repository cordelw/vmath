package vmath

import "math"

/* = Vector 2 ======================= */
type V2f [2]float64

// Addition
func (a V2f) Add(b V2f) V2f {
	return V2f{
		a[0] + b[0],
		a[1] + b[1],
	}
}

func (a V2f) AddN(n1 float64) V2f {
	return V2f{
		a[0] + n1,
		a[1] + n1,
	}
}

// Subtraction
func (a V2f) Sub(b V2f) V2f {
	return V2f{
		a[0] - b[0],
		a[1] - b[1],
	}
}

func (a V2f) SubN(b float64) V2f {
	return V2f{
		a[0] - b,
		a[1] - b,
	}
}

// Multiplication
func (a V2f) Mul(b float64) V2f {
	return V2f{
		a[0] * b,
		a[1] * b,
	}
}

func (a V2f) DotProd(b V2f) float64 {
	return (a[0] * b[0]) + (a[1] * b[1])
}

func (a V2f) CrossProd(b V2f) float64 {
	return (a[0] * b[1]) - (a[1] * b[0])
}

// Util
func (a V2f) Len() float64 {
	return math.Sqrt((a[0] * a[0]) + (a[1] * a[1]))
}

func (a V2f) Abs() V2f {
	return V2f{
		math.Abs(a[0]),
		math.Abs(a[1]),
	}
}

func (a V2f) Norm() V2f {
	len := a.Len()
	return V2f{
		a[0] / len,
		a[1] / len,
	}
}

/* ================================== */

/* = Vector 3 ======================= */
type V3f [3]float64

// Addition
func (a V3f) Add(b V3f) V3f {
	return V3f{
		a[0] + b[0],
		a[1] + b[1],
	}
}

func (a V3f) AddN(n1 float64) V3f {
	return V3f{
		a[0] + n1,
		a[1] + n1,
	}
}

// Subtraction
func (a V3f) Sub(b V3f) V3f {
	return V3f{
		a[0] - b[0],
		a[1] - b[1],
	}
}

func (a V3f) SubN(b float64) V3f {
	return V3f{
		a[0] - b,
		a[1] - b,
	}
}

// Multiplication
func (a V3f) Mul(b float64) V3f {
	return V3f{
		a[0] * b,
		a[1] * b,
	}
}

func (a V3f) DotProd(b V3f) float64 {
	return (a[0] * b[0]) + (a[1] * b[1])
}

func (a V3f) CrossProd(b V3f) float64 {
	return (a[0] * b[1]) - (a[1] * b[0])
}

// Util
func (a V3f) Len() float64 {
	return math.Sqrt((a[0] * a[0]) + (a[1] * a[1]))
}

func (a V3f) Abs() V3f {
	return V3f{
		math.Abs(a[0]),
		math.Abs(a[1]),
	}
}

func (a V3f) Norm() V3f {
	len := a.Len()
	return V3f{
		a[0] / len,
		a[1] / len,
	}
}

/* ================================== */
